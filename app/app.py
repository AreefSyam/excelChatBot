import base64
import streamlit as st
from lida import Manager, TextGenerationConfig, llm
from dotenv import load_dotenv
import os
import openai
from PIL import Image
from io import BytesIO
import tempfile
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load environment variables
load_dotenv()
openai_api_key = os.getenv("OPENAI_API_KEY")

# Initialize LIDA Manager once
lida = Manager(text_gen=llm("openai"))

# Use cheapest and supported model
textgen_config = TextGenerationConfig(
    n=1,
    temperature=0.2,
    model="gpt-4o-mini",
    use_cache=True
)

# Sidebar menu
menu = st.sidebar.selectbox("Choose an Option", ["Summarize", "Question based Graph"])


# Convert Base64 ‚Üí image
def base64_to_image(base64_string):
    byte_data = base64.b64decode(base64_string)
    return Image.open(BytesIO(byte_data))


# Handle uploaded CSV/XLSX
def handle_file_processing(uploaded_file):
    file_extension = uploaded_file.name.split('.')[-1].lower()
    if file_extension in ['csv', 'xlsx']:
        if file_extension == 'csv':
            df = pd.read_csv(uploaded_file)
        else:
            df = pd.read_excel(uploaded_file)

        temp_path = os.path.join(tempfile.gettempdir(), uploaded_file.name)
        if file_extension == 'csv':
            df.to_csv(temp_path, index=False)
        else:
            df.to_excel(temp_path, index=False)

        return temp_path

    st.error("Unsupported file format.")
    return None


# Summarize data + auto-generate chart
def summarize_data(file_path):
    summary = lida.summarize(
        file_path, summary_method="default", textgen_config=textgen_config
    )

    st.subheader("üìå Summary")
    st.write(summary)

    goals = lida.goals(summary, n=1, textgen_config=textgen_config)
    st.subheader("üìå Suggested Goal")
    st.write(goals[0])

    charts = lida.visualize(
        summary=summary, goal=goals[0], textgen_config=textgen_config, library="seaborn"
    )

    if charts:
        img = base64_to_image(charts[0].raster)
        st.subheader("üìä Generated Visualization")
        st.image(img)
    else:
        st.warning("No charts were generated.")


# User query ‚Üí generate chart
def generate_query_based_graph(file_path, query):
    if not query:
        st.error("Please enter a query.")
        return

    st.info(f"Your Query: {query}")

    # Try LIDA/LLM-driven visualization first; fall back to local plotting on error
    try:
        # LIDA summary
        summary = lida.summarize(
            file_path, summary_method="default", textgen_config=textgen_config
        )

        # Generate chart from user goal/query
        charts = lida.visualize(
            summary=summary, goal=query, textgen_config=textgen_config
        )

        if charts:
            img = base64_to_image(charts[0].raster)
            st.subheader("üìä Generated Graph")
            st.image(img)
        else:
            st.warning("No charts generated by LIDA; generating a local fallback chart.")
            _local_monthly_barchart(file_path)
    except Exception as e:
        # Show a concise error then attempt a local fallback
        err = str(e)
        st.error("LLM/OpenAI error: " + (err[:300] + "..." if len(err) > 300 else err))
        st.info("Attempting to generate the requested chart locally as a fallback.")
        _local_monthly_barchart(file_path)


def _local_monthly_barchart(file_path):
    """Local fallback: aggregate by month and draw a bar chart.

    Heuristics:
    - Find a date-like column (name includes 'date'/'time') or attempt to parse the first column.
    - If a numeric column exists, sum it per month; otherwise count rows per month.
    """
    try:
        ext = os.path.splitext(file_path)[1].lower()
        if ext == ".csv":
            df = pd.read_csv(file_path)
        else:
            df = pd.read_excel(file_path)
    except Exception as read_err:
        st.error(f"Could not read file for local plotting: {read_err}")
        return

    if df.empty:
        st.warning("Uploaded file is empty ‚Äî nothing to plot.")
        return

    # Identify date column
    date_col = None
    for c in df.columns:
        lc = c.lower()
        if "date" in lc or "time" in lc or "datetime" in lc:
            date_col = c
            break

    if date_col is None:
        first_col = df.columns[0]
        try:
            df[first_col] = pd.to_datetime(df[first_col], errors="coerce")
            if df[first_col].notna().sum() > 0:
                date_col = first_col
        except Exception:
            date_col = None

    if date_col is None:
        st.error("Couldn't find a date/time column to aggregate by month for local plotting.")
        return

    df[date_col] = pd.to_datetime(df[date_col], errors="coerce")
    df = df.dropna(subset=[date_col])
    if df.empty:
        st.error("No valid dates found in the date column after parsing.")
        return

    df["_month"] = df[date_col].dt.to_period("M").astype(str)

    numeric_cols = df.select_dtypes(include=["number"]).columns.tolist()
    if numeric_cols:
        agg_col = numeric_cols[0]
        agg = df.groupby("_month")[agg_col].sum().reset_index()
        y_label = f"Sum of {agg_col}"
    else:
        agg = df.groupby("_month").size().reset_index(name="count")
        y_label = "Count"

    plt.figure(figsize=(10, 5))
    sns.barplot(x=agg.iloc[:, 0], y=agg.iloc[:, 1], palette="viridis")
    plt.xticks(rotation=45)
    plt.xlabel("Month")
    plt.ylabel(y_label)
    plt.title("Monthly barchart (local fallback)")
    plt.tight_layout()
    st.pyplot(plt)


# ----------------- UI -----------------

if menu == "Summarize":
    st.subheader("üìò Summarization of your Dataset")
    file_uploader = st.file_uploader("Upload your CSV or Excel", type=["csv", "xlsx"])

    if file_uploader:
        file_path = handle_file_processing(file_uploader)
        if file_path:
            summarize_data(file_path)

if menu == "Question based Graph":
    st.subheader("üîç Query Your Data to Generate Graph")
    file_uploader = st.file_uploader("Upload your CSV or Excel", type=["csv", "xlsx"])
    text_area = st.text_area("Enter your query here:", height=200)

    if st.button("Generate Graph") and file_uploader and text_area:
        file_path = handle_file_processing(file_uploader)
        if file_path:
            generate_query_based_graph(file_path, text_area)
            os.remove(file_path)
